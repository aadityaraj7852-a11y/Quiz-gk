<!doctype html>
<html>
<head>
<meta charset="utf-8">
<title>MCQ → question.docx (Final with images & autosave)</title>
<meta name="viewport" content="width=device-width,initial-scale=1">
<style>
  body{font-family:Arial;margin:14px;color:#111}
  .wrap{display:flex;gap:12px;flex-wrap:wrap}
  .col{flex:1;min-width:320px;border:1px solid #ddd;padding:12px;border-radius:8px;box-sizing:border-box}
  input,textarea,select,button{font-size:14px}
  input, textarea, select { width:100%; padding:8px; margin:6px 0; box-sizing:border-box; }
  button{padding:8px 12px;margin:6px 4px;border:0;border-radius:6px;cursor:pointer}
  .btn-green{background:#0b7a3e;color:#fff}
  .btn-blue{background:#0066cc;color:#fff}
  .btn-red{background:#c0392b;color:#fff}
  .muted{color:#666;font-size:13px}
  .preview-table{width:100%;border-collapse:collapse;margin-bottom:14px;border:2px solid #444}
  .preview-table td{border:1px solid #666;padding:6px;vertical-align:top}
  .img-preview{max-width:220px;display:block;margin-top:6px;border:1px solid #ccc}
  .small{font-size:13px;padding:6px 8px}
</style>
</head>
<body>
<h2>MCQ → question.docx (Images + Autosave)</h2>
<p class="muted">हर प्रश्न के लिए अलग boxed table — images embedded — autosave ON</p>

<div class="wrap">
  <div class="col" style="max-width:600px">
    <label>Module</label><input id="module" placeholder="Hindi / English">

    <label>Question</label><textarea id="question" rows="3" placeholder="Question statement"></textarea>
    <label>Question Image (optional)</label><input type="file" accept="image/*" id="questionImg">

    <label>Option A</label><input id="optA" placeholder="Option A">
    <label>Image A (optional)</label><input type="file" accept="image/*" id="imgA">

    <label>Option B</label><input id="optB" placeholder="Option B">
    <label>Image B (optional)</label><input type="file" accept="image/*" id="imgB">

    <label>Option C</label><input id="optC" placeholder="Option C">
    <label>Image C (optional)</label><input type="file" accept="image/*" id="imgC">

    <label>Option D</label><input id="optD" placeholder="Option D">
    <label>Image D (optional)</label><input type="file" accept="image/*" id="imgD">

    <label>Answer (A/B/C/D)</label><input id="answer" placeholder="A">

    <label>Solution</label><textarea id="solution" rows="2"></textarea>
    <label>Solution Image (optional)</label><input type="file" accept="image/*" id="solutionImg">

    <div style="display:flex;gap:8px">
      <div style="flex:1">
        <label>Positive Marks</label><input id="pm" value="1">
      </div>
      <div style="flex:1">
        <label>Negative Marks</label><input id="nm" value="0.6">
      </div>
    </div>

    <label>Language (optional)</label>
    <select id="language">
      <option value="">auto</option>
      <option value="en">en</option>
      <option value="hi">hi</option>
    </select>

    <div style="margin-top:10px">
      <button id="addBtn" class="btn-green">Add Question</button>
      <button id="clearBtn" class="small" style="background:#999;color:#fff">Clear Fields</button>
      <button id="exportJson" class="small" style="background:#444;color:#fff">Export JSON</button>
    </div>

    <hr>
    <label>JSON Import (paste array)</label>
    <textarea id="jsonArea" style="height:100px;font-family:monospace"></textarea>
    <div style="margin-top:8px">
      <button id="importBtn" class="btn-blue">Import JSON</button>
      <button id="clearJson" class="small" style="background:#777;color:#fff">Clear JSON</button>
    </div>

    <hr>
    <div style="margin-top:8px">
      <button id="exportBtn" class="btn-blue">Export question.docx</button>
      <span class="muted"> (Word में खोलें)</span>
    </div>
  </div>

  <div class="col">
    <h3>Preview</h3>
    <div id="previewArea" class="muted">No questions added.</div>
    <div style="margin-top:10px">
      <button id="removeLast" class="btn-red">Remove Last</button>
      <button id="resetAll" style="background:#7f8c8d;color:#fff">Clear All</button>
    </div>
    <p class="muted" style="margin-top:12px">Tip: छोटे JPG images इस्तेमाल करो (recommended).</p>
  </div>
</div>

<script>
/* ---------- State & Autosave ---------- */
const STORAGE_KEY = "mcq_docx_v1";
let questions = [];
let qno = 1;

function loadState(){
  try{
    const s = localStorage.getItem(STORAGE_KEY);
    if(s){
      const obj = JSON.parse(s);
      if(Array.isArray(obj.questions)){ questions = obj.questions; qno = obj.qno || (questions.length+1); renderPreview(); }
    }
  }catch(e){ console.warn(e); }
}
function saveState(){ try{ localStorage.setItem(STORAGE_KEY, JSON.stringify({questions,qno})); }catch(e){ console.warn(e); } }
loadState();

/* ---------- Helpers ---------- */
function $(id){ return document.getElementById(id); }
function getVal(id){ return $(id).value.trim(); }
function setVal(id,v){ $(id).value = v || ''; }
function isHindi(s){ return /[\u0900-\u097F]/.test(s||''); }
function readFile(input){ return new Promise(res=>{ const f = input.files && input.files[0]; if(!f) return res(null); const r=new FileReader(); r.onload=()=> res({name:f.name,type:f.type,dataURL:r.result}); r.readAsDataURL(f); }); }

/* ---------- Add Question ---------- */
$('addBtn').addEventListener('click', async ()=> {
  const questionText = getVal('question');
  if(!questionText){ alert('Question डालो'); return; }

  let lang = getVal('language');
  if(!lang) lang = (isHindi(questionText) || isHindi(getVal('optA')))? 'hi' : 'en';

  const qImg = await readFile($('questionImg'));
  const aImg = await readFile($('imgA'));
  const bImg = await readFile($('imgB'));
  const cImg = await readFile($('imgC'));
  const dImg = await readFile($('imgD'));
  const solImg = await readFile($('solutionImg'));

  const item = {
    module: getVal('module') || 'General',
    questionno: qno++,
    question: questionText,
    questionImg: qImg, // may be null
    option: [ getVal('optA'), getVal('optB'), getVal('optC'), getVal('optD') ],
    optionImg: [ aImg, bImg, cImg, dImg ],
    answer: getVal('answer'),
    solution: getVal('solution'),
    solutionImg: solImg,
    pm: getVal('pm') || '1',
    nm: getVal('nm') || '0',
    language: lang
  };

  questions.push(item);
  saveState();
  renderPreview();
  clearForm(false);
});

/* ---------- Clear / Remove / Reset ---------- */
$('clearBtn').addEventListener('click', ()=> clearForm(true));
$('removeLast').addEventListener('click', ()=> { if(!questions.length) return alert('Nothing to remove'); questions.pop(); saveState(); renderPreview(); });
$('resetAll').addEventListener('click', ()=> { if(!confirm('Clear all questions?')) return; questions=[]; qno=1; saveState(); renderPreview(); });

function clearForm(all=true){
  if(all) setVal('module','');
  setVal('question',''); $('questionImg').value='';
  setVal('optA',''); $('imgA').value=''; setVal('optB',''); $('imgB').value=''; setVal('optC',''); $('imgC').value=''; setVal('optD',''); $('imgD').value='';
  setVal('answer',''); setVal('solution',''); $('solutionImg').value='';
  setVal('pm','1'); setVal('nm','0.6'); $('language').value='';
}

/* ---------- Preview ---------- */
function renderPreview(){
  const area = $('previewArea'); area.innerHTML = '';
  if(!questions.length){ area.innerHTML = '<div class="muted">No questions added.</div>'; return; }

  questions.forEach(q=>{
    const tbl = document.createElement('table'); tbl.className='preview-table';
    function addRow(name, text, img){
      const tr = document.createElement('tr');
      const td1 = document.createElement('td'); td1.className='left'; td1.textContent = name;
      const td2 = document.createElement('td'); td2.className='right';
      if(text) { const p=document.createElement('div'); p.textContent = text; td2.appendChild(p); }
      if(img && img.dataURL){ const im=document.createElement('img'); im.src = img.dataURL; im.className='img-preview'; td2.appendChild(im); }
      tr.appendChild(td1); tr.appendChild(td2); tbl.appendChild(tr);
    }
    addRow('Module', q.module, null);
    addRow('questionno', q.questionno, null);
    addRow('Question', q.question, q.questionImg);
    addRow('Type', 'mcq', null);
    addRow('option', q.option[0]||'', q.optionImg[0]);
    addRow('option', q.option[1]||'', q.optionImg[1]);
    addRow('option', q.option[2]||'', q.optionImg[2]);
    addRow('option', q.option[3]||'', q.optionImg[3]);
    addRow('answer', q.answer||'', null);
    addRow('Solution', q.solution||'', q.solutionImg);
    addRow('Positive Marks', q.pm||'', null);
    addRow('Negative Marks', q.nm||'', null);
    addRow('language', q.language||'', null);
    area.appendChild(tbl);
  });
}

/* ---------- JSON Import/Export ---------- */
$('importBtn').addEventListener('click', ()=>{
  try{
    const arr = JSON.parse($('jsonArea').value);
    if(!Array.isArray(arr)) return alert('JSON should be an array of question objects');
    arr.forEach(it=>{ it.questionno = qno++; questions.push(it); });
    saveState(); renderPreview(); alert('Imported ' + arr.length + ' questions');
  }catch(e){ alert('Invalid JSON: ' + e.message); }
});
$('clearJson').addEventListener('click', ()=> $('jsonArea').value = '');
$('exportJson').addEventListener('click', ()=> {
  if(!questions.length) return alert('No questions');
  const blob = new Blob([JSON.stringify(questions,null,2)], {type:'application/json'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href = url; a.download = 'mcq_export.json'; a.click();
  setTimeout(()=> URL.revokeObjectURL(url),3000);
});

/* ---------- DOCX BUILD (images embedded) ---------- */

/* XML escape */
function xmlEscape(s){ if(s==null) return ''; return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }

/* Collect media (list of {qIndex, field, data:{name,type,dataURL}}) */
function collectMedia(){
  const list = [];
  questions.forEach((q,qi)=>{
    if(q.questionImg && q.questionImg.dataURL) list.push({qIndex:qi, field:'questionImg', data:q.questionImg});
    (q.optionImg||[]).forEach((oi, idx)=>{ if(oi && oi.dataURL) list.push({qIndex:qi, field:'optionImg'+idx, data:oi}); });
    if(q.solutionImg && q.solutionImg.dataURL) list.push({qIndex:qi, field:'solutionImg', data:q.solutionImg});
  });
  return list;
}

/* make drawing xml referencing r:embed id */
function makeDrawingXml(rId, cx=4500000, cy=3000000){
  return `<w:r>
    <w:drawing>
      <wp:inline xmlns:wp="http://schemas.openxmlformats.org/drawingml/2006/wordprocessingDrawing">
        <wp:extent cx="${cx}" cy="${cy}"/>
        <wp:docPr id="1" name="Image"/>
        <a:graphic xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main">
          <a:graphicData uri="http://schemas.openxmlformats.org/drawingml/2006/picture">
            <pic:pic xmlns:pic="http://schemas.openxmlformats.org/drawingml/2006/picture">
              <pic:nvPicPr><pic:cNvPr id="0" name="Image"/><pic:cNvPicPr/></pic:nvPicPr>
              <pic:blipFill><a:blip xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships" r:embed="${rId}"/><a:stretch><a:fillRect/></a:stretch></pic:blipFill>
              <pic:spPr><a:xfrm><a:off x="0" y="0"/><a:ext cx="${cx}" cy="${cy}"/></a:xfrm><a:prstGeom prst="rect"><a:avLst/></a:prstGeom></pic:spPr>
            </pic:pic>
          </a:graphicData>
        </a:graphic>
      </wp:inline>
    </w:drawing>
  </w:r>`;
}

/* build row xml with optional drawing */
function makeRowXml(name, value, rId, cx, cy){
  const imagePart = rId ? `<w:p>${makeDrawingXml(rId,cx,cy)}</w:p>` : '';
  return `<w:tr>
    <w:tc><w:tcPr><w:shd w:fill="FFFFFF"/></w:tcPr><w:p><w:r><w:t>${xmlEscape(name)}</w:t></w:r></w:p></w:tc>
    <w:tc><w:tcPr><w:shd w:fill="FFE39C"/></w:tcPr><w:p><w:r><w:t>${xmlEscape(value)}</w:t></w:r></w:p>${imagePart}</w:tc>
  </w:tr>`;
}

/* build table xml for one question */
function buildTableXml(q, rmap){
  let rows='';
  rows += makeRowXml('Module', q.module || '', null);
  rows += makeRowXml('questionno', String(q.questionno), null);
  rows += makeRowXml('Question', q.question || '', rmap.questionImg, rmap.questionCx, rmap.questionCy);
  rows += makeRowXml('Type', 'mcq', null);
  for(let i=0;i<4;i++){
    rows += makeRowXml('option', q.option[i] || '', rmap['optionImg'+i], rmap['optionImg'+i+'Cx'], rmap['optionImg'+i+'Cy']);
  }
  rows += makeRowXml('answer', q.answer || '', null);
  rows += makeRowXml('Solution', q.solution || '', rmap.solutionImg, rmap.solutionCx, rmap.solutionCy);
  rows += makeRowXml('Positive Marks', q.pm || '', null);
  rows += makeRowXml('Negative Marks', q.nm || '', null);
  rows += makeRowXml('language', q.language || '', null);

  return `<w:tbl>
    <w:tblPr>
      <w:tblBorders>
        <w:top w:val="single" w:sz="12"/>
        <w:left w:val="single" w:sz="12"/>
        <w:right w:val="single" w:sz="12"/>
        <w:bottom w:val="single" w:sz="12"/>
        <w:insideH w:val="single" w:sz="8"/>
        <w:insideV w:val="single" w:sz="8"/>
      </w:tblBorders>
    </w:tblPr>
    ${rows}
  </w:tbl>
  <w:p><w:r><w:t></w:t></w:r></w:p>`;
}

/* Build package files: document.xml, rels, content types, media */
function buildPackageFiles(){
  const mediaList = collectMedia(); // {qIndex,field,data}
  const mediaFiles = []; // {name,type,u8,ref}
  const relIds = [];

  mediaList.forEach((it, idx)=>{
    const d = it.data;
    const comma = d.dataURL.indexOf(',');
    const b64 = d.dataURL.slice(comma+1);
    const binStr = atob(b64);
    const u8 = new Uint8Array(binStr.length);
    for(let i=0;i<binStr.length;i++) u8[i] = binStr.charCodeAt(i);
    let ext='png';
    if(d.type && d.type.indexOf('jpeg')!==-1) ext='jpg';
    else if(d.type && d.type.indexOf('png')!==-1) ext='png';
    else { const m=(d.name||'').match(/\.(png|jpe?g|gif|bmp)$/i); if(m) ext=m[1].toLowerCase(); }
    const name = `image${idx+1}.${ext}`;
    mediaFiles.push({name, type: d.type||('image/'+ext), data: u8, ref: it});
    relIds.push('rIdImg'+(idx+1));
  });

  // map rIds to questions
  const rmapPerQ = questions.map(()=>({
    questionImg:null, questionCx:0, questionCy:0,
    optionImg0:null, optionImg0Cx:0, optionImg0Cy:0,
    optionImg1:null, optionImg1Cx:0, optionImg1Cy:0,
    optionImg2:null, optionImg2Cx:0, optionImg2Cy:0,
    optionImg3:null, optionImg3Cx:0, optionImg3Cy:0,
    solutionImg:null, solutionCx:0, solutionCy:0
  }));

  mediaFiles.forEach((m, idx)=>{
    const it = m.ref; const qidx = it.qIndex;
    const rId = relIds[idx];
    const defCx = 4500000, defCy = 3000000;
    if(it.field === 'questionImg'){ rmapPerQ[qidx].questionImg = rId; rmapPerQ[qidx].questionCx = defCx; rmapPerQ[qidx].questionCy = defCy; }
    else if(it.field.startsWith('optionImg')){ const n = Number(it.field.replace('optionImg','')); rmapPerQ[qidx]['optionImg'+n] = rId; rmapPerQ[qidx]['optionImg'+n+'Cx'] = 3500000; rmapPerQ[qidx]['optionImg'+n+'Cy'] = 2000000; }
    else if(it.field === 'solutionImg'){ rmapPerQ[qidx].solutionImg = rId; rmapPerQ[qidx].solutionCx = defCx; rmapPerQ[qidx].solutionCy = defCy; }
  });

  // build document body
  let body = '';
  questions.forEach((q, qi)=> body += buildTableXml(q, rmapPerQ[qi]) );

  const documentXml = `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<w:document xmlns:w="http://schemas.openxmlformats.org/wordprocessingml/2006/main"
            xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships"
            xmlns:wp="http://schemas.openxmlformats.org/drawingml/2006/wordprocessingDrawing"
            xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main"
            xmlns:pic="http://schemas.openxmlformats.org/drawingml/2006/picture">
  <w:body>
    ${body}
    <w:p/><w:sectPr/>
  </w:body>
</w:document>`;

  // relationships for images
  let relsXml = `<?xml version="1.0" encoding="UTF-8"?>\n<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">`;
  mediaFiles.forEach((m,i)=> relsXml += `\n  <Relationship Id="${relIds[i]}" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/image" Target="media/${m.name}"/>`);
  relsXml += `\n</Relationships>`;

  // content types
  const extMap = {};
  mediaFiles.forEach(m => { const ext = m.name.split('.').pop(); extMap[ext] = m.type; });
  let ctXml = `<?xml version="1.0" encoding="UTF-8"?>\n<Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types">\n`;
  ctXml += `  <Default Extension="rels" ContentType="application/vnd.openxmlformats-package.relationships+xml"/>\n`;
  ctXml += `  <Default Extension="xml" ContentType="application/xml"/>\n`;
  Object.keys(extMap).forEach(ext => { ctXml += `  <Default Extension="${ext}" ContentType="${extMap[ext]}"/>\n`; });
  ctXml += `  <Override PartName="/word/document.xml" ContentType="application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml"/>\n</Types>`;

  // package files map
  const files = {};
  files["[Content_Types].xml"] = ctXml;
  files["_rels/.rels"] = `<?xml version="1.0"?>\n<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">\n  <Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument" Target="word/document.xml"/>\n</Relationships>`;
  files["word/document.xml"] = documentXml;
  files["word/_rels/document.xml.rels"] = relsXml;
  mediaFiles.forEach(m => files[`word/media/${m.name}`] = m.data);
  return files;
}

/* ZIP builder (binary-safe) */
function buildZipBlob(files){
  function toUint8(x){ if(typeof x === 'string') return new TextEncoder().encode(x); if(x instanceof Uint8Array) return x; if(x instanceof ArrayBuffer) return new Uint8Array(x); throw new Error('Unsupported file data'); }
  function uint32LE(n){ return [n & 0xff,(n>>8)&0xff,(n>>16)&0xff,(n>>24)&0xff]; }
  const crcTable = (function(){ let c; const table = new Uint32Array(256); for(let n=0;n<256;n++){ c=n; for(let k=0;k<8;k++){ c=(c&1)?(0xEDB88320^(c>>>1)):(c>>>1);} table[n]=c>>>0;} return table; })();
  function crc32(buf){ let crc = 0 ^ (-1); for(let i=0;i<buf.length;i++) crc = (crc>>>8) ^ crcTable[(crc ^ buf[i]) & 0xff]; return (crc ^ (-1)) >>> 0; }

  const localParts = [], centralParts = [];
  let offset = 0;
  for(const name in files){
    const data = toUint8(files[name]);
    const fname = new TextEncoder().encode(name);
    const crc = crc32(data);
    const compSize = data.length, uncompSize = data.length;

    const lh = new Uint8Array(30 + fname.length);
    lh.set([0x50,0x4b,0x03,0x04],0);
    lh.set([20,0],4);
    lh.set([0,0],6);
    lh.set([0,0],8);
    lh.set([0,0,0,0],10);
    lh.set(uint32LE(crc),14);
    lh.set(uint32LE(compSize),18);
    lh.set(uint32LE(uncompSize),22);
    lh.set([fname.length & 0xff, (fname.length>>8)&0xff],26);
    lh.set(fname,30);
    localParts.push({lh,data});
    offset += lh.length + data.length;

    const ch = new Uint8Array(46 + fname.length);
    ch.set([0x50,0x4b,0x01,0x02],0);
    ch.set([20,0],4); ch.set([20,0],6);
    ch.set([0,0],8); ch.set([0,0],10);
    ch.set([0,0,0,0],12);
    ch.set(uint32LE(crc),16);
    ch.set(uint32LE(compSize),20);
    ch.set(uint32LE(uncompSize),24);
    ch.set([fname.length & 0xff, (fname.length>>8)&0xff],28);
    ch.set([0,0,0,0],30); ch.set([0,0,0,0],32);
    ch.set([0,0],36); ch.set([0,0,0,0],38);
    const localStart = offset - (lh.length + data.length);
    ch.set(uint32LE(localStart),42);
    ch.set(fname,46);
    centralParts.push(ch);
  }

  let totalLocal = 0; localParts.forEach(it => totalLocal += it.lh.length + it.data.length);
  let centralSize = 0; centralParts.forEach(c => centralSize += c.length);
  const eocdSize = 22;
  const out = new Uint8Array(totalLocal + centralSize + eocdSize);
  let p = 0;
  localParts.forEach(it => { out.set(it.lh, p); p += it.lh.length; out.set(it.data, p); p += it.data.length; });
  const cdStart = p;
  centralParts.forEach(c => { out.set(c, p); p += c.length; });
  const cdSize = p - cdStart;
  out.set([0x50,0x4b,0x05,0x06], p); p += 4;
  out.set([0,0], p); p += 2;
  out.set([0,0], p); p += 2;
  const entries = centralParts.length;
  out.set([ entries & 0xff, (entries>>8)&0xff ], p); p += 2;
  out.set([ entries & 0xff, (entries>>8)&0xff ], p); p += 2;
  out.set(uint32LE(cdSize), p); p += 4;
  out.set(uint32LE(cdStart), p); p += 4;
  out.set([0,0], p); p += 2;
  return new Blob([out], {type:"application/vnd.openxmlformats-officedocument.wordprocessingml.document"});
}

/* ---------- Export DOCX ---------- */
$('exportBtn').addEventListener('click', ()=> {
  if(!questions.length) return alert('पहले कम से कम एक प्रश्न जोड़ो');
  try{
    const files = buildPackageFiles();
    const blob = buildZipBlob(files);
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a'); a.href = url; a.download = 'question.docx'; a.click();
    setTimeout(()=> URL.revokeObjectURL(url), 5000);
  }catch(e){ console.error(e); alert('Export failed: ' + e.message); }
});

/* helper that wraps buildZipBlob to accept files (handles binary media) */
function buildZipBlob(filesMap){
  // For media entries stored as Uint8Array, our buildZipBlob function handles those.
  return buildZipBlobBinary(filesMap);
}

/* Reuse the exact binary zip builder above but with available scope - implement wrapper */
function buildZipBlobBinary(files){
  return buildZipBlob(files); // buildZipBlob defined earlier in this script scope
}

/* Since buildZipBlob was declared after usage, ensure functions exist: create alias */
function buildZipBlob(files){ return (function buildZipLocal(filesLocal){
  // inline same as buildZipBlob above to ensure it's available
  function toUint8(x){ if(typeof x === 'string') return new TextEncoder().encode(x); if(x instanceof Uint8Array) return x; if(x instanceof ArrayBuffer) return new Uint8Array(x); throw new Error('Unsupported file data'); }
  function uint32LE(n){ return [n & 0xff,(n>>8)&0xff,(n>>16)&0xff,(n>>24)&0xff]; }
  const crcTable = (function(){ let c; const table = new Uint32Array(256); for(let n=0;n<256;n++){ c=n; for(let k=0;k<8;k++){ c=(c&1)?(0xEDB88320^(c>>>1)):(c>>>1);} table[n]=c>>>0;} return table; })();
  function crc32(buf){ let crc = 0 ^ (-1); for(let i=0;i<buf.length;i++) crc = (crc>>>8) ^ crcTable[(crc ^ buf[i]) & 0xff]; return (crc ^ (-1)) >>> 0; }

  const localParts = [], centralParts = [];
  let offset = 0;
  for(const name in filesLocal){
    const data = toUint8(filesLocal[name]);
    const fname = new TextEncoder().encode(name);
    const crc = crc32(data);
    const compSize = data.length, uncompSize = data.length;

    const lh = new Uint8Array(30 + fname.length);
    lh.set([0x50,0x4b,0x03,0x04],0);
    lh.set([20,0],4);
    lh.set([0,0],6);
    lh.set([0,0],8);
    lh.set([0,0,0,0],10);
    lh.set(uint32LE(crc),14);
    lh.set(uint32LE(compSize),18);
    lh.set(uint32LE(uncompSize),22);
    lh.set([fname.length & 0xff, (fname.length>>8)&0xff],26);
    lh.set(fname,30);
    localParts.push({lh,data});
    offset += lh.length + data.length;

    const ch = new Uint8Array(46 + fname.length);
    ch.set([0x50,0x4b,0x01,0x02],0);
    ch.set([20,0],4); ch.set([20,0],6);
    ch.set([0,0],8); ch.set([0,0],10);
    ch.set([0,0,0,0],12);
    ch.set(uint32LE(crc),16);
    ch.set(uint32LE(compSize),20);
    ch.set(uint32LE(uncompSize),24);
    ch.set([fname.length & 0xff, (fname.length>>8)&0xff],28);
    ch.set([0,0,0,0],30); ch.set([0,0,0,0],32);
    ch.set([0,0],36); ch.set([0,0,0,0],38);
    const localStart = offset - (lh.length + data.length);
    ch.set(uint32LE(localStart),42);
    ch.set(fname,46);
    centralParts.push(ch);
  }

  let totalLocal = 0; localParts.forEach(it => totalLocal += it.lh.length + it.data.length);
  let centralSize = 0; centralParts.forEach(c => centralSize += c.length);
  const eocdSize = 22;
  const out = new Uint8Array(totalLocal + centralSize + eocdSize);
  let p = 0;
  localParts.forEach(it => { out.set(it.lh, p); p += it.lh.length; out.set(it.data, p); p += it.data.length; });
  const cdStart = p;
  centralParts.forEach(c => { out.set(c, p); p += c.length; });
  const cdSize = p - cdStart;
  out.set([0x50,0x4b,0x05,0x06], p); p += 4;
  out.set([0,0], p); p += 2;
  out.set([0,0], p); p += 2;
  const entries = centralParts.length;
  out.set([ entries & 0xff, (entries>>8)&0xff ], p); p += 2;
  out.set([ entries & 0xff, (entries>>8)&0xff ], p); p += 2;
  out.set(uint32LE(cdSize), p); p += 4;
  out.set(uint32LE(cdStart), p); p += 4;
  out.set([0,0], p); p += 2;
  return new Blob([out], {type:"application/vnd.openxmlformats-officedocument.wordprocessingml.document"});
})(files); }

/* ---------- init ---------- */
renderPreview();

</script>
</body>
</html>
